[{"name":"app.R","content":"library(shiny)\r\nlibrary(ggplot2)\r\nlibrary(patchwork)\r\nlibrary(viridis)\r\nlibrary(dplyr)\r\nlibrary(grid)\r\n\r\ntheme_set(theme_minimal(base_size = 12, base_family = \"Arial\"))\r\n\r\n# ===========================================================\r\n# --- Helper Functions ---\r\n# ===========================================================\r\n\r\n# Initialize spatial positions of cells\r\ninitialize_positions <- function(n_cells, geometry = \"monolayer\", L = 100) {\r\n  if (geometry == \"monolayer\") {\r\n    x <- runif(n_cells, 0, L)\r\n    y <- runif(n_cells, 0, L)\r\n    return(data.frame(cell_id = 1:n_cells, x = x, y = y))\r\n  } else if (geometry == \"spheroid\") {\r\n    coords <- matrix(NA, nrow = n_cells, ncol = 3)\r\n    i <- 1\r\n    while (i <= n_cells) {\r\n      point <- runif(3, -L, L)\r\n      if (sum(point^2) <= L^2) {\r\n        coords[i,] <- point\r\n        i <- i + 1\r\n      }\r\n    }\r\n    return(data.frame(cell_id = 1:n_cells, x = coords[,1], y = coords[,2], z = coords[,3]))\r\n  }\r\n}\r\n\r\n# Compute crowding factor (neighbor density effects)\r\ncompute_crowding <- function(positions, radius = 10,\r\n                             kernel = c(\"flat\",\"gaussian\"),\r\n                             mode   = c(\"inhibit\",\"promote\"),\r\n                             beta   = 1.0,\r\n                             clamp  = c(0.2, 2.0)) {\r\n  kernel <- match.arg(kernel); mode <- match.arg(mode)\r\n  n <- nrow(positions)\r\n  dens <- numeric(n)\r\n  \r\n  for (i in 1:n) {\r\n    dx <- positions$x - positions$x[i]\r\n    dy <- positions$y - positions$y[i]\r\n    if (\"z\" %in% names(positions)) {\r\n      dz <- positions$z - positions$z[i]\r\n      d  <- sqrt(dx^2 + dy^2 + dz^2)\r\n    } else {\r\n      d  <- sqrt(dx^2 + dy^2)\r\n    }\r\n    if (kernel == \"flat\") {\r\n      dens[i] <- sum(d > 0 & d < radius)\r\n    } else {\r\n      sigma <- radius/2\r\n      w <- exp(-0.5 * (d/sigma)^2)\r\n      w[d == 0] <- 0\r\n      dens[i] <- sum(w[d < 3*radius])\r\n    }\r\n  }\r\n  \r\n  dens_ref <- max(median(dens), 1e-6)\r\n  if (mode == \"inhibit\") {\r\n    f <- 1 / (1 + beta * (dens/dens_ref))\r\n  } else {\r\n    f <- 1 + beta * (dens/dens_ref)\r\n  }\r\n  \r\n  f <- pmax(clamp[1], pmin(clamp[2], f))\r\n  list(factor = f, density = dens, density_ref = dens_ref)\r\n}\r\n\r\n# Initialize T cells\r\ninitialize_tcells <- function(n_tcells, geometry = \"spheroid\", L = 100, placement = \"random\") {\r\n  tpos <- initialize_positions(n_tcells, geometry, L)\r\n  tpos$kills <- 0L\r\n  tpos\r\n}\r\n\r\n# Core simulation function\r\ntimes <- seq(0,24,by=1)\r\nsimulate_cell <- function(therapy, dose, cell_id, \r\n                          x = NA, y = NA, z = NULL,\r\n                          crowding_factor = 1,\r\n                          ischemia_rate = 0.05,\r\n                          ischemia_pattern = \"none\",\r\n                          resistance_prob = 0.1,\r\n                          spatial = FALSE,\r\n                          infection_window = 1,\r\n                          superinfection_resistance = TRUE,\r\n                          delivery_mode = \"random\",\r\n                          tcell_positions = NULL,\r\n                          kill_radius = 10,\r\n                          antigen_threshold = 1000,\r\n                          recognition_variability = 0.2,\r\n                          max_kills_per_tcell = 10,\r\n                          enable_tcell_killing = TRUE,\r\n                          enable_ischemia_mod = TRUE,\r\n                          enable_crowding_mod = TRUE,\r\n                          geometry = \"monolayer\") {\r\n  \r\n  mRNA <- 0; replicase <- 0; Protein <- 0; sub_mRNA <- 0; superinfected <- FALSE\r\n  alive <- TRUE; killers <- 0; kill_time <- NA; killer_id <- NA\r\n  \r\n  if (spatial) {\r\n    distance_from_center <- sqrt(x^2 + y^2 + ifelse(!is.null(z), z^2, 0))\r\n    max_dist <- if (!is.null(z)) sqrt(3)*50 else sqrt(2)*50\r\n    \r\n    if (ischemia_pattern == \"center\") {\r\n      ischemia_factor <- exp(-ischemia_rate * (max_dist - distance_from_center))\r\n    } else if (ischemia_pattern == \"periphery\") {\r\n      ischemia_factor <- exp(-ischemia_rate * distance_from_center)\r\n    } else {\r\n      ischemia_factor <- 1\r\n    }\r\n    \r\n    if (delivery_mode == \"center\") {\r\n      dose_eff <- dose * exp(-distance_from_center / 20)\r\n    } else if (delivery_mode == \"random\") {\r\n      dose_eff <- dose * runif(1, 0.5, 1.5)\r\n    } else if (delivery_mode == \"border\") {\r\n      dose_eff <- dose * (distance_from_center / max_dist)\r\n    } else {\r\n      dose_eff <- dose\r\n    }\r\n    \r\n    dose_eff <- dose_eff * crowding_factor\r\n  } else {\r\n    dose_eff <- dose\r\n    ischemia_factor <- 1\r\n  }\r\n  \r\n  is_resistant <- runif(1) < resistance_prob\r\n  resistance_factor <- if (is_resistant) 0.3 else 1.0\r\n  \r\n  Protein_max <- if (is_resistant) rnorm(1, mean = 1500, sd = 300) else rnorm(1, mean = 5000, sd = 1000)\r\n  Protein_max <- max(Protein_max, 500)\r\n  transcription_rate <- if (is_resistant) rnorm(1, mean = therapy$rates[\"k1\"] * 0.2, sd = 0.05) else rnorm(1, mean = therapy$rates[\"k1\"], sd = 0.1)\r\n  transcription_rate <- transcription_rate * crowding_factor * ischemia_factor\r\n  transcription_rate <- max(transcription_rate, 0)\r\n  \r\n  out <- data.frame(time = times, Antigen = NA, Antigen_vaccine = NA, Antigen_innate = NA)\r\n  \r\n  if (!is.null(tcell_positions)) local_tcell_kills <- integer(nrow(tcell_positions))\r\n  \r\n  for (t in times) {\r\n    if (!alive) break\r\n    \r\n    if (t <= infection_window) {\r\n      lambda <- dose_eff\r\n      new_mRNA <- rpois(1, lambda)\r\n      mRNA <- mRNA + new_mRNA\r\n      if (superinfection_resistance && new_mRNA > 0) superinfected <- TRUE\r\n    }\r\n    \r\n    replicase <- replicase + rpois(1, transcription_rate * mRNA)\r\n    sub_mRNA <- sub_mRNA + rpois(1, therapy$rates[\"k2\"] * replicase)\r\n    eff_rate <- sub_mRNA * (1 - Protein / Protein_max)\r\n    eff_rate <- eff_rate * resistance_factor * ischemia_factor * crowding_factor\r\n    Protein <- Protein + rpois(1, pmax(eff_rate,0))\r\n    \r\n    out$Antigen[times == t] <- Protein\r\n    out$Antigen_vaccine[times == t] <- Protein\r\n    out$Antigen_innate[times == t] <- rpois(1, 50)\r\n    \r\n    if (enable_tcell_killing && !is.null(tcell_positions) && spatial) {\r\n      dx <- tcell_positions$x - x\r\n      dy <- tcell_positions$y - y\r\n      dz <- if(!is.null(z) && \"z\" %in% names(tcell_positions)) tcell_positions$z - z else 0\r\n      dists <- sqrt(dx^2 + dy^2 + dz^2)\r\n      nearby_idx <- which(dists <= kill_radius)\r\n      if (length(nearby_idx) > 0) {\r\n        for (ti in nearby_idx) {\r\n          if (local_tcell_kills[ti] >= max_kills_per_tcell) next\r\n          antigen_signal <- out$Antigen_vaccine[times==t]\r\n          threshold <- antigen_threshold * runif(1, 1-recognition_variability, 1+recognition_variability)\r\n          prob <- pmin(1, antigen_signal/(threshold+1))\r\n          if (enable_ischemia_mod) prob <- prob * ischemia_factor\r\n          if (enable_crowding_mod) prob <- prob * crowding_factor\r\n          if (runif(1) < prob) {\r\n            alive <- FALSE\r\n            killers <- killers + 1\r\n            kill_time <- t\r\n            killer_id <- ti\r\n            local_tcell_kills[ti] <- local_tcell_kills[ti] + 1L\r\n            break\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n  \r\n  out$cell_id <- cell_id\r\n  out$superinfected <- superinfected\r\n  out$Protein_max <- Protein_max\r\n  out$transcription_rate <- transcription_rate\r\n  out$is_resistant <- is_resistant\r\n  out$dose_eff <- dose_eff\r\n  out$alive <- alive\r\n  out$kill_time <- kill_time\r\n  out$killer_id <- killer_id\r\n  if (spatial) {\r\n    out$x <- x; out$y <- y\r\n    if (!is.null(z)) out$z <- z\r\n    out$crowding_factor <- crowding_factor\r\n    out$ischemia_factor <- ischemia_factor\r\n    out$distance <- distance_from_center\r\n  }\r\n  return(out)\r\n}\r\n\r\n# Therapy placeholder\r\ntherapies <- list(Replicon=list(rates=c(k1=1.0, k2=4.0), name=\"Replicon\"))\r\n\r\n# ===========================================================\r\n# --- UI ---\r\n# ===========================================================\r\nui <- fluidPage(\r\n  titlePanel(\"sa-mRNA Immunotherapy model (SAMI)\"),\r\n  sidebarLayout(\r\n    sidebarPanel(\r\n      numericInput(\"n_cells\", \"Tumor Cells:\", 1000, min=50, max=2000, step=50),\r\n      numericInput(\"n_tcells\", \"T Cells:\", 50, min=0, max=200, step=10),\r\n      sliderInput(\"dose\", \"Dose:\", min=0, max=1000, value=10),\r\n      selectInput(\"geometry\", \"Geometry:\", choices=c(\"monolayer\",\"spheroid\"), selected=\"spheroid\"),\r\n      checkboxInput(\"vary_radius\", \"Vary Spheroid Radius (Fixed # Cells)\", value = TRUE), \r\n      conditionalPanel ( condition = \"input.vary_radius == true\", textInput(\"radii\", \"Spheroid Radii (comma-separated):\", \"50,100\")),\r\n      selectInput(\"delivery_mode\", \"Delivery Mode (sa-mRNA and T cells):\", choices=c(\"random\",\"center\",\"border\"), selected=\"border\"),\r\n      numericInput(\"crowding_radius\", \"Crowding Radius (How far are neighbors):\", 10, min=1, max=20),\r\n      numericInput(\"crowding_beta\", \"Crowding Beta (Regulatory effect of neighbors):\", 0.5, step=0.1),\r\n      numericInput(\"ischemia_rate\", \"Ischemia Rate (Regulation by Ischemia):\", 0.05, step=0.01),\r\n      selectInput(\"ischemia_pattern\", \"Ischemia Pattern:\", choices=c(\"center\",\"none\",\"periphery\")),\r\n      numericInput(\"tcell_kill_radius\", \"T Cell Kill Radius (How far T cells kill):\", 20, min=1, max=50),\r\n      numericInput(\"tcell_antigen_threshold\", \"T Cell Antigen Threshold (How much antigen required):\", 2000, step=100),\r\n      sliderInput(\"tcell_recognition_variability\", \"T Cell Recognition Variability:\", min=0, max=1, value=0.1),\r\n      numericInput(\"tcell_max_kills\", \"T Cell Max Kills per Hour (Time Step):\", 0.2, min=0, max=10),\r\n      sliderInput(\"infection_window\", \"Infection Window (h):\", min=1, max=24, value=1),\r\n      numericInput(\"n_replicates\", \"Number of Replicates:\", 1, min=1, max=10, step=1),\r\n      actionButton(\"run_sim\", \"Run Simulation\"),\r\n      hr(),\r\n      downloadButton(\"downloadFig1\", \"Download Figure 1\"),\r\n      downloadButton(\"downloadFig2\", \"Download Figure 2\"),\r\n      downloadButton(\"downloadFig3\", \"Download Figure 3\"),\r\n      downloadButton(\"downloadFig4\", \"Download Figure 4\")\r\n    ),\r\n    mainPanel(\r\n      tabsetPanel(\r\n        tabPanel(\"Figure 1\", plotOutput(\"fig1Plot\", height=\"900px\")),\r\n        tabPanel(\"Figure 2\", plotOutput(\"fig2Plot\", height=\"900px\")),\r\n        tabPanel(\"Figure 3\", plotOutput(\"fig3Plot\", height=\"900px\")),\r\n        tabPanel(\"Figure 4\", plotOutput(\"fig4Plot\", height=\"900px\"))\r\n        \r\n      )\r\n    )\r\n  )\r\n)\r\n\r\n# ===========================================================\r\n# --- SERVER ---\r\n# ===========================================================\r\nserver <- function(input, output, session) {\r\n  \r\n  sim_data <- eventReactive(input$run_sim, {\r\n    set.seed(123)\r\n    all_results <- list()\r\n  \r\n    # Parse user radii if enabled\r\n    if (input$vary_radius) {\r\n      radii <- as.numeric(unlist(strsplit(input$radii, \",\")))\r\n    } else {\r\n      radii <- 50  # default single radius\r\n    }\r\n    \r\n    for (replicate_id in 1:input$n_replicates) {\r\n      for (spheroid_radius in radii) {\r\n        \r\n        n_cells <- input$n_cells\r\n        spheroid_volume <- (4/3) * pi * spheroid_radius^3\r\n        spheroid_density <- n_cells / spheroid_volume\r\n        \r\n        message(paste(\"Replicate\", replicate_id,\r\n                      \"Radius\", spheroid_radius,\r\n                      \"-> Volume =\", round(spheroid_volume, 1),\r\n                      \"Density =\", signif(spheroid_density, 3)))\r\n        \r\n        # Initialize positions and crowding\r\n        positions <- initialize_positions(n_cells, geometry = input$geometry, L = spheroid_radius)\r\n        cinfo <- compute_crowding(positions, \r\n                                  radius = input$crowding_radius, \r\n                                  beta = input$crowding_beta, \r\n                                  kernel = \"gaussian\", \r\n                                  mode = \"inhibit\")\r\n        positions$crowding_factor <- cinfo$factor\r\n        positions$neighbors <- cinfo$density\r\n        \r\n        # Initialize T cells\r\n        tcell_positions <- initialize_tcells(input$n_tcells, geometry = input$geometry, L = spheroid_radius, placement = delivery_mode)\r\n        \r\n        # Run simulations\r\n        reps <- lapply(1:nrow(positions), function(i){\r\n          pos <- positions[i, ]\r\n          simulate_cell(\r\n            therapy = therapies$Replicon,\r\n            dose = input$dose,\r\n            cell_id = pos$cell_id,\r\n            x = pos$x, y = pos$y, z = if(\"z\" %in% names(pos)) pos$z else NULL,\r\n            crowding_factor = pos$crowding_factor,\r\n            ischemia_rate = input$ischemia_rate,\r\n            ischemia_pattern = input$ischemia_pattern,\r\n            spatial = TRUE,\r\n            delivery_mode = input$delivery_mode,\r\n            tcell_positions = tcell_positions,\r\n            kill_radius = input$tcell_kill_radius,\r\n            antigen_threshold = input$tcell_antigen_threshold,\r\n            recognition_variability = input$tcell_recognition_variability,\r\n            max_kills_per_tcell = input$tcell_max_kills,\r\n            infection_window = input$infection_window,\r\n            geometry = input$geometry\r\n          )\r\n        })\r\n        \r\n        df <- bind_rows(reps)\r\n        df$dose <- input$dose\r\n        df$replicate_id <- replicate_id\r\n        df$spheroid_radius <- spheroid_radius\r\n        df$spheroid_volume <- spheroid_volume\r\n        df$spheroid_density <- spheroid_density\r\n        df <- df |> left_join(positions[, c(\"cell_id\",\"neighbors\",\"crowding_factor\")], by = \"cell_id\")\r\n        \r\n        all_results[[paste(replicate_id, spheroid_radius, sep = \"_\")]] <- df\r\n      }\r\n    }\r\n    \r\n    all_results <- bind_rows(all_results)\r\n\r\n  })\r\n  \r\n  # --- Figure 1 ---\r\n  fig1_obj <- reactive({\r\n    df <- sim_data(); req(df)\r\n    final_spatial <- df %>% filter(time==max(time)) %>% mutate(dist_center=sqrt(x^2 + y^2 + ifelse(!is.na(z), z^2,0)))\r\n    agg_df <- df %>% group_by(time, neighbors) %>% summarise(mean_Antigen=mean(Antigen, na.rm=TRUE), .groups=\"drop\")\r\n    \r\n    pA1 <- ggplot(final_spatial, aes(x=neighbors)) +\r\n      geom_density(aes(group=replicate_id), color=\"grey70\", alpha=0.5) +\r\n      stat_density(geom=\"line\", color=\"black\", linewidth=1.2) +\r\n      labs(title=\"Neighbors per Cell\", x=\"Neighbor Count\", y=\"Frequency\")\r\n    \r\n    pB1 <- ggplot(agg_df, aes(x=time, y=mean_Antigen, group=neighbors, color=neighbors)) +\r\n      geom_line(linewidth=1) + scale_color_viridis_c(option=\"plasma\") +\r\n      labs(title=\"GFP kinetics\", x=\"Time (h)\", y=\"GFP MFI\")\r\n    \r\n    df_plot <- df %>% filter(time %in% c(0,6,12,18,24))\r\n    pC1 <- ggplot(df_plot, aes(x=x, y=y, color=Antigen)) +\r\n      geom_point(size=1.5) + scale_color_viridis(option=\"C\") +\r\n      facet_wrap(~time,ncol=5) + coord_fixed() + theme(panel.spacing=unit(2,\"lines\")) +\r\n      labs(title=\"GFP spatial over time\", x=\"X\", y=\"Y\")\r\n    \r\n    pD1 <- ggplot(final_spatial, aes(x=neighbors, y=Antigen)) +\r\n      geom_point(alpha=0.3, color=\"green\") + geom_smooth(method=\"loess\", se=FALSE, color=\"black\") +\r\n      labs(title=\"GFP vs neighbors\", x=\"Neighbor Count\", y=\"GFP\")\r\n    \r\n    pE1 <- ggplot(final_spatial, aes(x=dist_center, y=Antigen)) +\r\n      geom_point(alpha=0.3, color=\"green\") + geom_smooth(method=\"loess\", se=FALSE, color=\"black\") +\r\n      labs(title=\"GFP vs distance\", x=\"Distance\", y=\"GFP\")\r\n    \r\n    (pA1 | pB1) / (pC1) / (pD1 | pE1) + plot_annotation(tag_levels=\"A\")\r\n  })\r\n  \r\n  output$fig1Plot <- renderPlot({ fig1_obj() })\r\n  \r\n  # --- Figure 2 ---\r\n  fig2_obj <- reactive({\r\n    df <- sim_data(); req(df)\r\n    df_24 <- df %>% filter(time==max(time))\r\n    df_24$killed <- ifelse(df_24$alive,\"Alive\",\"Killed\")\r\n    \r\n    pA2 <- ggplot(df_24, aes(x=x, y=y, color=killed)) +\r\n      geom_point(size=2) + scale_color_manual(values=c(\"Alive\"=\"darkgreen\",\"Killed\"=\"red\")) +\r\n      coord_fixed() + labs(title=\"Tumor Cell Status\", x=\"X\", y=\"Y\")\r\n    \r\n    tcell_activity_filtered <- df_24 %>% filter(!is.na(killer_id)) %>%\r\n      mutate(neighbors_int = round(neighbors)) %>%\r\n      group_by(killer_id, neighbors_int) %>%\r\n      summarise(kills = n(), .groups=\"drop\")\r\n    \r\n    pB2 <- ggplot(tcell_activity_filtered, aes(x=factor(neighbors_int), y=kills)) +\r\n      geom_jitter(width=0.2, alpha=0.1, color=\"darkblue\") +\r\n      geom_boxplot(fill=\"skyblue\", alpha=0.5) +\r\n      labs(title=\"T Cell Activity\", x=\"Neighbor Count\", y=\"Kills\")+\r\n      theme(axis.text.x = element_text(angle = 90, hjust = 0.5))\r\n    \r\n    kill_24h_reps <- df_24 %>% mutate(neighbors_int = round(neighbors)) %>%\r\n      group_by(neighbors_int) %>% summarise(frac_alive = mean(alive), .groups=\"drop\")\r\n    \r\n    pC2 <- ggplot(kill_24h_reps, aes(x=neighbors_int, y=1-frac_alive)) +\r\n      geom_point(size=2, alpha=0.3, position=position_jitter(width=0.2)) +\r\n      geom_smooth() +\r\n      labs(title=\"Tumor Cytotoxicity\", x=\"Neighbor Count\", y=\"Fraction Killed\")\r\n    \r\n    (pA2 / pB2 / pC2) +\r\n      plot_layout(heights = c(1, 1.5, 1)) +\r\n      plot_annotation(tag_levels = \"A\")\r\n  })\r\n  \r\n  output$fig2Plot <- renderPlot({ fig2_obj() })\r\n\r\n  # --- Figure 3 ---\r\n  fig3_obj <- reactive({\r\n    df <- sim_data(); req(df)\r\n    if (!\"spheroid_radius\" %in% names(df)) {\r\n      showNotification(\"Figure 3: No spheroid radius data detected — enable 'Vary Radius' in settings.\", type=\"warning\")\r\n      return(NULL)\r\n    }\r\n    \r\n    final_spatial <- df %>%\r\n      filter(time == max(time)) %>%\r\n      mutate(dist_center = sqrt(x^2 + y^2 + ifelse(!is.na(z), z^2, 0)))\r\n    \r\n    agg_df <- df %>%\r\n      group_by(time, neighbors, spheroid_radius) %>%\r\n      summarise(mean_Antigen = mean(Antigen, na.rm = TRUE), .groups = \"drop\")\r\n    \r\n    # A: Neighbor distribution by radius\r\n    pA3 <- ggplot(final_spatial, aes(x = neighbors, color = factor(spheroid_radius), fill = factor(spheroid_radius))) +\r\n      geom_density(alpha = 0.3) +\r\n      labs(title = \"Neighbors per Cell by Spheroid Radius\",\r\n           x = \"Neighbor Count\", y = \"Frequency\", color = \"Radius\", fill = \"Radius\") +\r\n      theme_minimal(base_size = 15)\r\n    \r\n    # B: GFP kinetics colored by radius\r\n    df_summary <- df %>%\r\n      group_by(time, spheroid_radius) %>%\r\n      summarise(mean_Antigen = mean(Antigen, na.rm = TRUE),\r\n                sd_Antigen = sd(Antigen, na.rm = TRUE),\r\n                .groups = \"drop\")\r\n\r\n    pB3 <- ggplot(df_summary, aes(x = time, y = mean_Antigen,\r\n                                  color = factor(spheroid_radius),\r\n                                  group = spheroid_radius)) +\r\n      geom_line(size = 1.2) +\r\n      geom_ribbon(aes(ymin = mean_Antigen - sd_Antigen,\r\n                      ymax = mean_Antigen + sd_Antigen,\r\n                      fill = factor(spheroid_radius)),\r\n                  alpha = 0.5, color = NA) +\r\n      labs(title = \"Antigen Expression Kinetics by Spheroid Radius\",\r\n           x = \"Time (h)\",\r\n           y = \"Mean Antigen (GFP)\",\r\n           color = \"Radius\",\r\n           fill = \"Radius\") +\r\n      theme_minimal(base_size = 16)\r\n    \r\n    # C: Spatial plots over time, faceted by radius\r\n    df_plot <- df %>% filter(time %in% c(0,6,12,18,24))\r\n    pC3 <- ggplot(df_plot, aes(x = x, y = y, color = Antigen)) +\r\n      geom_point(size = 1.2) +\r\n      scale_color_viridis(option = \"C\") +\r\n      facet_grid(spheroid_radius ~ time, labeller = label_both) +\r\n      coord_fixed() +\r\n      labs(title = \"GFP Spatial Distribution over Time & Radius\", x = \"X\", y = \"Y\") +\r\n      theme_minimal(base_size = 14) +\r\n      theme(panel.spacing = unit(1, \"lines\"))\r\n    \r\n    # D: GFP vs neighbors, colored by radius\r\n    pD3 <- ggplot(final_spatial, aes(x = neighbors, y = Antigen,\r\n                                     color = factor(spheroid_radius))) +\r\n      geom_point(alpha = 0.5) +\r\n      geom_smooth(se = FALSE) +\r\n      labs(title = \"GFP vs Neighbors\", x = \"Neighbor Count\",\r\n           y = \"GFP\", color = \"Radius\") +\r\n      theme_minimal(base_size = 15)\r\n    \r\n    # E: GFP vs distance from center, colored by radius\r\n    pE3 <- ggplot(final_spatial, aes(x = dist_center, y = Antigen,\r\n                                     color = factor(spheroid_radius))) +\r\n      geom_point(alpha = 0.5) +\r\n      geom_smooth(se = FALSE) +\r\n      labs(title = \"GFP vs Distance\", x = \"Distance from Center\",\r\n           y = \"GFP\", color = \"Radius\") +\r\n      theme_minimal(base_size = 15)\r\n    \r\n    (pA3 | pB3) / pC3 / (pD3 | pE3) + \r\n      plot_layout(heights = c(1, 1.5, 1)) +\r\n      plot_annotation(tag_levels = \"A\")\r\n  })\r\n  \r\n  output$fig3Plot <- renderPlot({ fig3_obj() })\r\n  \r\n  # --- Figure 4 ---\r\n  fig4_obj <- reactive({\r\n    df <- sim_data(); req(df)\r\n    if (!\"spheroid_radius\" %in% names(df)) {\r\n      showNotification(\"Figure 4: No spheroid radius data detected — enable 'Vary Radius' in settings.\", type=\"warning\")\r\n      return(NULL)\r\n    }\r\n    \r\n    df_24 <- df %>% filter(time == max(time))\r\n    df_24$killed <- ifelse(df_24$alive, \"Alive\", \"Killed\")\r\n    \r\n    # A: Tumor cell status by radius\r\n    pA4 <- ggplot(df_24, aes(x = x, y = y, color = killed)) +\r\n      geom_point(size = 1.8, alpha = 0.7) +\r\n      scale_color_manual(values = c(\"Alive\" = \"darkgreen\", \"Killed\" = \"red\")) +\r\n      coord_fixed() +\r\n      facet_wrap(~ spheroid_radius, labeller = label_both) +\r\n      labs(title = \"Tumor Cell Status by Spheroid Radius\", x = \"X\", y = \"Y\", color = \"Status\") +\r\n      theme_minimal(base_size = 15)\r\n    \r\n    # B: T-cell activity, colored/faceted by radius\r\n    tcell_activity <- df_24 %>%\r\n      filter(!is.na(killer_id)) %>%\r\n      mutate(neighbors_int = round(neighbors)) %>%\r\n      group_by(killer_id, neighbors_int, spheroid_radius) %>%\r\n      summarise(kills = n(), .groups = \"drop\")\r\n    \r\n    pB4 <- ggplot(tcell_activity, aes(x = factor(neighbors_int), y = kills,\r\n                                      color = factor(spheroid_radius))) +\r\n      geom_jitter(width = 0.2, alpha = 0.4) +\r\n      geom_boxplot(alpha = 0.4, outlier.shape = NA) +\r\n      theme(axis.text.x = element_text(angle = 90, hjust = 0.5))+\r\n      labs(title = \"T-Cell Activity by Spheroid Radius\",\r\n           x = \"Neighbor Count\", y = \"Kills\", color = \"Radius\") \r\n      \r\n    \r\n    # C: Cytotoxicity curves by radius\r\n    kill_frac <- df_24 %>%\r\n      mutate(neighbors_int = round(neighbors)) %>%\r\n      group_by(neighbors_int, spheroid_radius) %>%\r\n      summarise(frac_alive = mean(alive), .groups = \"drop\")\r\n    \r\n    pC4 <- ggplot(kill_frac, aes(x = neighbors_int, y = 1 - frac_alive,\r\n                                 color = factor(spheroid_radius),\r\n                                 group = spheroid_radius)) +\r\n      geom_point(size = 2, alpha = 0.8, position = position_jitter(width = 0.2)) +\r\n      geom_smooth(se = FALSE, linewidth = 1.2) +\r\n      labs(title = \"Tumor Cytotoxicity by Radius\",\r\n           x = \"Neighbor Count\", y = \"Fraction Killed\", color = \"Radius\") +\r\n      theme_minimal(base_size = 15)\r\n    \r\n    (pA4 / pB4 / pC4) +\r\n      plot_layout(heights = c(1, 1.5, 1)) +\r\n      plot_annotation(tag_levels = \"A\")\r\n  })\r\n  \r\n  output$fig4Plot <- renderPlot({ fig4_obj() })\r\n  \r\n  \r\n  # --- Download handlers ---\r\n  output$downloadFig1 <- downloadHandler(\r\n    filename = function(){ \"Figure1.png\" },\r\n    content = function(file){ ggsave(file, fig1_obj(), width=12, height=10, dpi=300) }\r\n  )\r\n  \r\n  output$downloadFig2 <- downloadHandler(\r\n    filename = function(){ \"Figure2.png\" },\r\n    content = function(file){ ggsave(file, fig2_obj(), width=12, height=10, dpi=300) }\r\n  )\r\n  \r\n  output$downloadFig3 <- downloadHandler(\r\n    filename = function(){ \"Figure3.png\" },\r\n    content = function(file){ ggsave(file, fig3_obj(), width=10, height=10, dpi=300) }\r\n  )\r\n  \r\n  output$downloadFig4 <- downloadHandler(\r\n    filename = function(){ \"Figure4.png\" },\r\n    content = function(file){ ggsave(file, fig4_obj(), width=10, height=10, dpi=300) }\r\n  )\r\n  \r\n}\r\n\r\n# ===========================================================\r\n# --- Run App ---\r\n# ===========================================================\r\nshinyApp(ui, server)\r\n","type":"text"}]
